<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mediapipe Pose Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
      #container {
        display: flex;
        align-items: flex-start;
      }
      #output_canvas {
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Mediapipe Pose Tracking</h1>
    <div id="container">
      <video class="input_video" style="display: none"></video>
      <canvas id="output_canvas" width="932" height="642"></canvas>
      <canvas id="answer_canvas" width="932" height="642"></canvas>
    </div>
    <p id="similarityScoreDistance" style="font-size: 24px; color: green">
      거리 기반 유사도: 0%
    </p>
    <p id="similarityScoreAngle" style="font-size: 24px; color: blue">
      각도 기반 유사도: 0%
    </p>

    <script>
      const videoElement = document.querySelector(".input_video");
      const outputCanvas = document.getElementById("output_canvas");
      const outputCtx = outputCanvas.getContext("2d");

      const answerCanvas = document.getElementById("answer_canvas");
      const answerCtx = answerCanvas.getContext("2d");

      const similarityScoreDistanceElement = document.getElementById(
        "similarityScoreDistance"
      );
      const similarityScoreAngleElement = document.getElementById(
        "similarityScoreAngle"
      );

      let answerPoseLandmarks = null; // 정답 포즈 랜드마크
      let answerVisibleLandmarks = null; // 정답 포즈에서 드러나는 랜드마크
      let answerImage = new Image(); // 정답 이미지 객체
      const answerImagePath = "sonny.png"; // 정답 이미지 경로
      answerImage.src = answerImagePath; // 정답 이미지 로드

      // Mediapipe Pose 설정
      const pose = new Pose({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
      });

      pose.setOptions({
        modelComplexity: 2,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      function getVisibleLandmarks(landmarks) {
        // 모든 랜드마크를 반환 (visibility 기준 제거)
        return landmarks.filter((landmark) => landmark);
      }

      async function loadAnswerPose() {
        await new Promise((resolve) => (answerImage.onload = resolve));

        answerCanvas.width = answerImage.width;
        answerCanvas.height = answerImage.height;
        answerCanvas.style.width = `${answerImage.width}px`;
        answerCanvas.style.height = `${answerImage.height}px`;

        const offscreenCanvas = document.createElement("canvas");
        offscreenCanvas.width = answerImage.width;
        offscreenCanvas.height = answerImage.height;
        const offscreenCtx = offscreenCanvas.getContext("2d");
        offscreenCtx.drawImage(
          answerImage,
          0,
          0,
          answerImage.width,
          answerImage.height
        );

        return new Promise((resolve, reject) => {
          pose.onResults((results) => {
            if (results.poseLandmarks) {
              answerPoseLandmarks = results.poseLandmarks;
              answerVisibleLandmarks = getVisibleLandmarks(answerPoseLandmarks); // 정답 이미지에서 드러나는 랜드마크 저장
              answerCtx.clearRect(
                0,
                0,
                answerCanvas.width,
                answerCanvas.height
              );
              answerCtx.drawImage(answerImage, 0, 0);
              resolve(true);
            } else {
              resolve(false);
            }
          });

          pose.send({ image: offscreenCanvas }).catch((error) => {
            reject(error);
          });
        });
      }

      // 벡터 간의 각도를 계산하는 함수
      function calculateAngle(firstLandmark, midLandmark, lastLandmark) {
        if (!firstLandmark || !midLandmark || !lastLandmark) return null;

        const radians =
          Math.atan2(
            lastLandmark.y - midLandmark.y,
            lastLandmark.x - midLandmark.x
          ) -
          Math.atan2(
            firstLandmark.y - midLandmark.y,
            firstLandmark.x - midLandmark.x
          );

        let degrees = Math.abs(radians * (180.0 / Math.PI)); // 각도를 절대값으로 변환
        if (degrees > 180.0) {
          degrees = 360.0 - degrees; // 예각으로 변환
        }
        return degrees;
      }

      // 공통으로 감지된 랜드마크만을 사용하여 각도 계산
      function getPoseAngles(landmarks) {
        if (!landmarks) return null;

        const angles = {
          leftShoulder: calculateAngle(
            landmarks[11],
            landmarks[13],
            landmarks[15]
          ),
          rightShoulder: calculateAngle(
            landmarks[12],
            landmarks[14],
            landmarks[16]
          ),
          leftElbow: calculateAngle(
            landmarks[11],
            landmarks[13],
            landmarks[23]
          ),
          rightElbow: calculateAngle(
            landmarks[12],
            landmarks[14],
            landmarks[24]
          ),
          frontLegHip: calculateAngle(
            landmarks[23],
            landmarks[25],
            landmarks[27]
          ),
          backKnee: calculateAngle(landmarks[24], landmarks[26], landmarks[28]),
          waist: calculateAngle(landmarks[11], landmarks[23], landmarks[25]),
        };

        // null 값을 가진 각도를 제외하고 반환
        const validAngles = {};
        for (const key in angles) {
          if (angles[key] !== null) {
            validAngles[key] = angles[key];
          }
        }

        console.log("Calculated Angles:", validAngles); // 디버깅용 로그
        return validAngles;
      }

      // 거리 기반 유사도 계산
      function calculateDistanceSimilarity(poseLandmarks1, poseLandmarks2) {
        if (!poseLandmarks1 || !poseLandmarks2) return null;

        let totalDifference = 0;
        let count = 0;

        answerVisibleLandmarks.forEach((landmark1, index) => {
          const landmark2 = poseLandmarks2[index];
          if (landmark1 && landmark2) {
            const dx = landmark1.x - landmark2.x;
            const dy = landmark1.y - landmark2.y;
            totalDifference += Math.sqrt(dx * dx + dy * dy);
            count++;
          }
        });

        if (count === 0) return null;

        return 1 / (1 + totalDifference / count);
      }

      // 각도 기반 유사도 계산 (공통으로 감지된 각도들만 사용)
      function calculateAngleSimilarity(
        answerAngles,
        currentAngles,
        tolerance = 10
      ) {
        if (!answerAngles || !currentAngles) return null;

        let totalDifference = 0;
        let count = 0;

        for (const key in answerAngles) {
          if (answerAngles[key] !== null && currentAngles[key] !== null) {
            const difference = Math.abs(answerAngles[key] - currentAngles[key]);
            console.log(`Angle difference for ${key}: ${difference}`); // 각도 차이 디버깅
            if (difference <= tolerance) {
              // 허용 오차 내의 차이만 비교
              totalDifference += difference;
              count++;
            }
          } else {
            console.log(
              `Skipping ${key} due to null values in either answer or current pose`
            ); // null인 각도를 건너뛰는 경우 로깅
          }
        }

        if (count === 0) {
          console.log("No comparable angles found."); // 비교할 각도가 없는 경우
          return null;
        }

        const similarityScore = 1 / (1 + totalDifference / count);
        console.log(`Angle Similarity Score: ${similarityScore}`);
        return similarityScore;
      }

      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
      });
      camera.start();

      function onResults(results) {
        outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
        outputCtx.save();
        outputCtx.scale(-1, 1);
        outputCtx.translate(-outputCanvas.width, 0);

        outputCtx.drawImage(
          results.image,
          0,
          0,
          outputCanvas.width,
          outputCanvas.height
        );

        if (results.poseLandmarks) {
          drawConnectors(
            outputCtx,
            results.poseLandmarks,
            Pose.POSE_CONNECTIONS,
            { color: "#00FF00", lineWidth: 4 }
          );
          drawLandmarks(outputCtx, results.poseLandmarks, {
            color: "#FF0000",
            lineWidth: 2,
          });

          if (answerVisibleLandmarks) {
            const distanceSimilarity = calculateDistanceSimilarity(
              answerVisibleLandmarks,
              results.poseLandmarks
            );
            if (distanceSimilarity !== null) {
              similarityScoreDistanceElement.innerText = `거리 기반 유사도: ${(
                distanceSimilarity * 100
              ).toFixed(2)}%`;
            }

            // 각도 기반 유사도 계산 및 표시
            const answerAngles = getPoseAngles(answerVisibleLandmarks);
            const currentAngles = getPoseAngles(results.poseLandmarks);
            const angleSimilarity = calculateAngleSimilarity(
              answerAngles,
              currentAngles,
              10
            ); // 10도 허용 오차
            if (angleSimilarity !== null) {
              similarityScoreAngleElement.innerText = `각도 기반 유사도: ${(
                angleSimilarity * 100
              ).toFixed(2)}%`;
            }
          }
        }
        outputCtx.restore();
      }

      loadAnswerPose()
        .then((success) => {
          if (success) {
            console.log("정답 포즈 로드가 완료되었습니다.");
            pose.onResults(onResults);
          } else {
            console.log("정답 포즈 로드에 실패했습니다.");
          }
        })
        .catch((error) => {
          console.error("정답 포즈 로드 중 오류 발생:", error);
        });
    </script>
  </body>
</html>
